# 🏷️ Lane Labeling Tools Collection

**차선 라벨링 및 데이터셋 관리를 위한 Python 도구 모음**

이 리포지토리는 컴퓨터 비전 프로젝트, 특히 차선 인식과 관련된 데이터셋 처리 및 관리를 위한 전문적인 Python 도구들을 제공합니다.

## 📋 도구 목록

### 1. 🎯 **Frame 번호 매칭 파일 복사기** (`copy_matching_frame_numbers`)

#### 📂 파일
- `copy_matching_frame_numbers.py`

#### 🎯 주요 기능
- **프레임 번호 추출**: 정규식을 사용하여 파일명에서 frame 번호를 추출
- **스마트 매칭**: Source와 Train 디렉토리에서 동일한 frame 번호를 가진 파일들을 자동 탐지
- **선택적 복사**: 중복된 frame 번호를 가진 Train 파일들만 Output 디렉토리로 복사

#### 🔧 기술적 세부사항
```python
# 지원하는 파일명 패턴:
# Source: frame_000004_png.rf.bc57731e2806e1eb3e0b4d66077b3627.jpg
# Train: frame_003754.png
# 추출되는 frame 번호: 000004, 003754
```

#### 💡 사용 사례
- 비디오에서 추출한 프레임과 라벨링된 프레임 간의 매칭
- 대용량 데이터셋에서 특정 프레임들만 필터링
- 차선 라벨링 프로젝트에서 검증용 데이터셋 구성

---

### 2. 🖼️ **COCO 어노테이션 이진 마스크 생성기** (`create_binary_masks`)

#### 📂 파일
- `create_binary_masks.py`

#### 🎯 주요 기능
- **COCO JSON 파싱**: COCO 형식의 어노테이션 파일을 로드하고 분석
- **세그멘테이션 → 마스크 변환**: 폴리곤 세그멘테이션 좌표를 이진 마스크로 변환
- **배치 처리**: 모든 이미지에 대해 자동으로 마스크 생성
- **시각화 지원**: 생성된 마스크의 샘플 미리보기 제공

#### 🔧 기술적 세부사항
```python
# 주요 라이브러리:
# - PIL (Image, ImageDraw): 폴리곤 렌더링
# - OpenCV: 이미지 저장 및 비트연산
# - NumPy: 효율적인 배열 처리
# - Matplotlib: 시각화

# 출력 형식: 흰색(255) = 차선, 검은색(0) = 배경
```

#### 💡 사용 사례
- 차선 세그멘테이션 모델 훈련용 Ground Truth 마스크 생성
- COCO 어노테이션을 픽셀 단위 마스크로 변환
- 의미론적 세그멘테이션 데이터셋 전처리

#### 📊 처리 결과 추적
- 전체 이미지 수 및 처리된 파일 수 리포트
- 어노테이션이 없는 파일들 별도 관리 (검은색 마스크 생성)
- 실패한 파일들에 대한 상세 오류 로그

---

### 3. 📊 **데이터셋 5분할 도구** (`dataset_splitter_5th`)

#### 📂 파일
- `dataset_splitter_5th.py`

#### 🎯 주요 기능
- **주기적 샘플링**: 정렬된 파일 목록에서 5번째마다 파일을 선택
- **안전한 이동**: 파일을 다른 디렉토리로 이동 (복사가 아닌 이동)
- **순서 보장**: 파일명 기준 정렬로 일관된 분할 결과 제공

#### 🔧 기술적 세부사항
```python
# 분할 로직:
MOVE_INTERVAL = 5  # 5개 중 1개 이동 (20% 분할)
# 선택되는 파일 인덱스: 5, 10, 15, 20, 25, ...

# 파일명 정렬 기준:
sorted([f for f in source_path.iterdir() if f.is_file()])
```

#### 💡 사용 사례
- 머신러닝 데이터셋의 Train/Validation 분할 (80:20 비율)
- 대용량 데이터셋에서 대표적인 샘플 추출
- 시계열 데이터에서 균등한 간격의 테스트 데이터 생성

---

### 4. 🔄 **디렉토리 동기화 정리기** (`dir_sync_cleanup`)

#### 📂 파일
- `dir_sync_cleanup.py`

#### 🎯 주요 기능
- **일방향 동기화**: 기준 디렉토리를 참조하여 대상 디렉토리 정리
- **파일명 기반 매칭**: 확장자를 포함한 정확한 파일명으로 비교
- **자동 정리**: 기준에 없는 파일들을 자동으로 삭제

#### 🔧 기술적 세부사항
```python
# 동기화 로직:
source_files = {f.name for f in source_path.iterdir() if f.is_file()}
# 집합(Set) 자료구조로 O(1) 검색 성능 보장

# 안전성:
# - 파일 단위 개별 처리
# - 예외 처리로 부분 실패 시에도 계속 진행
```

#### 💡 사용 사례
- 이미지 데이터셋과 라벨 데이터셋 간의 동기화
- 전처리 후 매칭되지 않는 파일들 정리
- 백업 디렉토리와 원본 디렉토리의 일관성 유지

---

### 5. 🗂️ **고급 디렉토리 제외기** (`directory_excluder`)

#### 📂 파일
- `directory_excluder.py`

#### 🎯 주요 기능
- **다중 비교 모드**: 파일명, 파일명+크기, 크기+파일명 기반 비교
- **유연한 처리 방식**: 삭제 또는 안전한 백업 폴더로 이동
- **미리보기 모드**: 실제 작업 전 결과 미리 확인
- **충돌 해결**: 동일 파일명 존재 시 자동 번호 추가

#### 🔧 기술적 세부사항
```python
# 비교 모드:
def get_files_by_comparison_mode(directory, mode):
    if mode == "name":          # 파일명만 비교
    elif mode == "size":        # 파일명 + 크기
    elif mode == "content":     # 크기 + 파일명 (해시 대신 크기 사용)

# 안전 기능:
# - 미리보기 모드: dry_run=True
# - 자동 백업: action="move"
# - 파일명 충돌 시 자동 번호 추가
```

#### 💡 사용 사례
- 훈련 데이터셋에서 검증용 파일들 제외
- 중복 파일 탐지 및 정리
- 조건부 파일 필터링 및 아카이빙

---

### 6. 🗂️ **디렉토리 파일 삭제기** (`directory_file_deleter`)

#### 📂 파일
- `directory_file_deleter.py`

#### 🎯 주요 기능
- **일괄 파일 삭제**: 지정된 디렉토리의 모든 파일을 안전하게 삭제
- **사용자 확인**: 실행 전 사용자 승인 프로세스
- **상세 로그**: 삭제 과정의 실시간 피드백

#### 💡 사용 사례
- 임시 파일 정리
- 프로젝트 초기화
- 테스트 데이터 제거

---

### 7. ⚡ **실시간 동기화 삭제 모니터** (`realtime_sync_deleter`)

#### 📂 파일
- `realtime_sync_deleter.py`

#### 🎯 주요 기능
- **실시간 모니터링**: Watchdog 라이브러리를 사용한 파일 시스템 이벤트 감지
- **자동 동기화**: 디렉토리1에서 파일 삭제 시 디렉토리2에서 동일 파일 자동 삭제
- **백그라운드 실행**: 데몬 프로세스로 상시 실행 가능

#### 🔧 기술적 세부사항
```python
# 필수 의존성:
pip install watchdog

# 모니터링 이벤트:
# - FileSystemEventHandler 상속
# - on_deleted 이벤트 처리
# - 파일명 기반 동기화
```

#### 💡 사용 사례
- 이미지 데이터셋과 라벨 데이터셋의 실시간 동기화
- 원본 파일과 처리된 파일의 일관성 유지
- 개발 환경에서의 자동 파일 관리

---

## 🛠️ 설치 및 사용법

### 필수 요구사항
```bash
# Python 3.6 이상
pip install opencv-python pillow numpy matplotlib

# 실시간 모니터링 도구용 (선택사항)
pip install watchdog
```

### 기본 사용법
```bash
# 각 도구는 독립적으로 실행 가능
cd copy_matching_frame_numbers
python copy_matching_frame_numbers.py

cd create_binary_masks
python create_binary_masks.py

# 다른 도구들도 동일한 방식으로 실행
```

### 경로 설정
모든 도구는 하드코딩된 경로를 사용합니다. 실제 환경에 맞게 각 Python 파일 내의 경로를 수정하세요:

```python
# 예시: copy_matching_frame_numbers.py
source = "C:/Users/USER/Tools/LongToShort/source"
train = "C:/Users/USER/Tools/LongToShort/train"
output = "C:/Users/USER/Tools/LongToShort/output"
```

## 🔧 기술적 특징

### 성능 최적화
- **Set/Dictionary 자료구조**: O(1) 검색 성능으로 대용량 파일 처리 지원
- **배치 처리**: 메모리 효율적인 파일 처리
- **정규식 최적화**: 컴파일된 패턴으로 빠른 문자열 매칭

### 안전성 보장
- **예외 처리**: 모든 파일 작업에 try-catch 구문 적용
- **사용자 확인**: 위험한 작업 전 명시적 승인 요구
- **상세 로깅**: 작업 과정의 투명한 추적
- **원자적 연산**: 개별 파일 단위 처리로 부분 실패 시에도 안정성 유지

### 크로스플랫폼 호환성
- **pathlib.Path 사용**: Windows/Linux/macOS 경로 자동 처리
- **인코딩 처리**: UTF-8 기본 지원으로 다국어 파일명 처리

## 📊 실제 사용 시나리오

### 차선 인식 프로젝트 워크플로우

1. **데이터 수집**: 비디오에서 프레임 추출
2. **라벨링**: 특정 프레임들에 대해 COCO 형식으로 어노테이션
3. **매칭**: `copy_matching_frame_numbers`로 라벨링된 프레임들만 추출
4. **마스크 생성**: `create_binary_masks`로 세그멘테이션 마스크 생성
5. **데이터셋 분할**: `dataset_splitter_5th`로 훈련/검증 데이터 분리
6. **동기화**: `dir_sync_cleanup`으로 이미지-라벨 일관성 유지
7. **실시간 관리**: `realtime_sync_deleter`로 개발 중 자동 동기화

### 대용량 데이터셋 관리

- **초기 정리**: `directory_excluder`로 중복 파일 제거
- **주기적 샘플링**: `dataset_splitter_5th`로 대표 샘플 추출
- **동기화 유지**: `dir_sync_cleanup`으로 정기적 정리
- **실시간 모니터링**: `realtime_sync_deleter`로 상시 동기화

## ⚠️ 주의사항 및 모범 사례

### 안전성 가이드라인
1. **백업 필수**: 중요한 데이터는 작업 전 반드시 백업
2. **소량 테스트**: 전체 데이터셋 적용 전 작은 샘플로 검증
3. **경로 확인**: 하드코딩된 경로를 실제 환경에 맞게 수정
4. **권한 확인**: 파일 읽기/쓰기 권한 확보
5. **디스크 공간**: 충분한 여유 공간 확보

### 성능 최적화 팁
- **로컬 저장소 사용**: 네트워크 드라이브보다 로컬 디스크 권장
- **SSD 권장**: 대용량 파일 처리 시 SSD 사용
- **메모리 관리**: 매우 큰 데이터셋의 경우 배치 크기 조정
- **동시 실행 주의**: 여러 도구 동시 실행 시 리소스 경합 주의

## 🤝 기여 및 개선사항

이 도구들은 실제 차선 라벨링 프로젝트에서 사용되며 지속적으로 개선되고 있습니다. 버그 리포트나 개선 제안은 언제든 환영합니다.

### 개선 계획
- [ ] GUI 인터페이스 추가
- [ ] 설정 파일 기반 경로 관리
- [ ] 더 많은 이미지 형식 지원
- [ ] 병렬 처리 옵션 추가
- [ ] 진행률 표시 개선

---

**개발자**: nevlife  
**라이선스**: MIT  
**최종 업데이트**: 2025년 7월